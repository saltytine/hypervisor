# armv8-baremetal-demo-rust

armv8 bare metal program written in rust.

## ~/.cargo/config
```shell
[target.aarch64-unknown-linux-gnu]
linker = "aarch64-linux-gnu-gcc"
rustflags = ["-C", "link-args=-nostartfiles -Tlinker.ld"]
```
you'll need to install linker: `apt-get install aarch64-linux-gnu-`
install the rust toolchain: `rustup install nightly && rustup default nightly && rustup target add aarch64-unknown-linux-gnu`

## compile
```shell
cargo clean && cargo build --target aarch64-unknown-linux-gnu
```
then copy to the target armv8 machine for execution

## qemu
    qemu-system-aarch64 \
    -M virt \
    -m 1024M \
    -cpu cortex-a53 \
    -nographic \
    -kernel target/aarch64-unknown-linux-gnu/debug/armv8-baremetal-demo-rust
## qemu debug
qemu-system-aarch64 \
    -M virt \
    -m 1024M \
    -cpu cortex-a53 \
    -nographic \
    -machine virtualization=on \
    #-machine secure=on \
    -kernel target/aarch64-unknown-linux-gnu/debug/armv8-baremetal-demo-rust \
    -S -s

-machine virutalization turns on virtualization, which enables el2, and -machine secure enables el3, we only really need to start from el2
then use aarch64-linux-gnu-gdb -x debug.gdb, qemu starts virt from el1 by default (yucky)
references:
https://github.com/cirosantilli/linux-kernel-module-cheat/tree/35684b1b7e0a04a68987056cb15abd97e3d2f0cc#arm-exception-level
https://stackoverflow.com/questions/31787617/what-is-the-current-execution-mode-exception-level-etc
https://stackoverflow.com/questions/42824706/qemu-system-aarch64-entering-el1-when-emulating-a53-power-up

## compile gdb for aarch64
1. Download gdb source: https://ftp.gnu.org/gnu/gdb/
2. tar -xzvf xxx
3. mkdir build
4. cd $_
5. ../configure --prefix=$PWD --target=aarch64-linux-gnu
6. make -j$(nproc) [CFALGS=-static CXXFLAGS=-static]

--target specifies the architecture of the program to be debugged, --host specifies the architecture of the gdb program to run
